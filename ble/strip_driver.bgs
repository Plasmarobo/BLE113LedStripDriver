const MAX_METERS = 15 #5m per strip
const MAX_LEDS = 480 #160 leds per m

dim meters 
dim led_count
dim i

dim write_ptr
dim read_ptr
#Create a 4 part buffer
dim stripA(256)
dim stripB(256)
dim stripC(256)
dim stripD(256)
dim stripE(256)
dim stripF(256)
dim zeros(15)

procedure write_pixels()
	read_ptr = 0
	while(read_ptr < write_ptr)
		if (read_ptr < 256)
			call hardware_spi_transfer(0, 1, stripA(read_ptr:1))
		else
			if (read_ptr < 512)
				call hardware_spi_transfer(0, 1, stripB((read_ptr-256):1))
			else 
				if (read_ptr < 768)
					call hardware_spi_transfer(0, 1, stripC((read_ptr-512):1))
				else 
					if (read_ptr < 1024)
						call hardware_spi_transfer(0, 1, stripD((read_ptr-768):1))
					else 
						if (read_ptr < 1280)
							call hardware_spi_transfer(0, 1, stripE((read_ptr-1024):1))
						else 
							if (read_ptr < 1536)
								call hardware_spi_transfer(0, 1, stripF((read_ptr-1280):1))
							end if
						end if
					end if
				end if
			end if
		end if
		read_ptr = read_ptr + 1
	end while
end

procedure write_reset()
	#Hard maximum 15 meters
	write_ptr = 0
	call hardware_spi_transfer(0, meters, "\x00\x00\x00\x00\x00")
end

procedure blank_strip()
	i = 0
	while(i < led_count)
		call hardware_spi_transfer(0,3,"\x80\x80\x80")
		i = i + 1
	end while
	call write_reset()
end


procedure set_strip_info(num_leds)
	led_count = num_leds
	meters = (led_count+31)/32
end

procedure set_color(v)
	if (write_ptr < 256)
		stripA(write_ptr:1) = v
	else
		if (write_ptr < 512)
			stripB((write_ptr-256):1) = v
		else 
			if (write_ptr < 768)
				stripC((write_ptr-512):1) = v
			else 
				if (write_ptr < 1024)
					stripD((write_ptr-768):1) = v
				else 
					if (write_ptr < 1280)
						stripE((write_ptr-1024):1) = v
					else 
						if (write_ptr < 1536)
							stripF((write_ptr-1280):1) = v
						end if
					end if
				end if
			end if
		end if
	end if
	write_ptr = write_ptr + 1
	if (write_ptr >= (led_count*3))
		call write_pixels()
		call write_reset()
	end if
end

#Values should have the high bit set
procedure set_rgb(r, g, b)
	#Little endian, grb -> brg
	call set_color(b | $80)
	call set_color(r | $80)
	call set_color(g | $80)
end



#Listen for boot
event system_boot(major, minor, patch, build,ll_version, protocol,hw)
	write_ptr = 0
	read_ptr = 0
	call set_strip_info(160)

	#call hardware_io_port_config_direction(1,1) #P1.0 is output
	call hardware_io_port_config_direction(1,3) #P1.1 is output
	call hardware_io_port_write(1,2,2)
	
	call gap_set_adv_parameters(320, 480, 7)

    # put module into discoverable/connectable mode
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
	call blank_strip()
	
	call hardware_set_soft_timer(65335, 2, 1)
end




#Listen for bluetooth
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)

end

event connection_disconnected(handle, result)
end

event attributes_value(connection, reason, handle, offset, vlen, value_data)
	if handle = c_led_data then
		call set_rgb(value_data(1), value_data(0), value_data(2))
	end if
end



event hardware_soft_timer(handle)
	if (handle = 1)
	
		call hardware_io_port_write(1,1,1)
		call blank_strip()
		call set_rgb(30,0,0)
		call set_rgb(0,30,0)
		call set_rgb(0,0,30)
		call write_pixels()
		call hardware_io_port_write(1,1,0)
	else
		call hardware_io_port_write(1,2,0)
		call hardware_set_soft_timer(32768, 1, 0)
	end if
end
