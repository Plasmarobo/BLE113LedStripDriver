const MAX_METERS = 15 #5m per strip
const MAX_LEDS = 480 #160 leds per m
const MAX_DATA_LEN = 1440

dim meters 
dim led_count
dim i

dim write_ptr
dim read_ptr

#Create a 4 part buffer
dim stripA(256)
dim stripB(256)
dim stripC(256)
dim stripD(256)
dim stripE(256)
dim stripF(256)

dim connected

# OTA Variables
dim command
dim dfu_pointer  # current pointer to flash location to upload firmware
dim erase_page   # current page to erase
const MAX_ERASE_PAGE = 64

procedure write_pixels()
	read_ptr = 0
	while(read_ptr < write_ptr)
		if (read_ptr < 256)
			call hardware_spi_transfer(0, 1, stripA(read_ptr:1))
		else
			if (read_ptr < 512)
				call hardware_spi_transfer(0, 1, stripB((read_ptr-256):1))
			else 
				if (read_ptr < 768)
					call hardware_spi_transfer(0, 1, stripC((read_ptr-512):1))
				else 
					if (read_ptr < 1024)
						call hardware_spi_transfer(0, 1, stripD((read_ptr-768):1))
					else 
						if (read_ptr < 1280)
							call hardware_spi_transfer(0, 1, stripE((read_ptr-1024):1))
						else 
							if (read_ptr < 1536)
								call hardware_spi_transfer(0, 1, stripF((read_ptr-1280):1))
							end if
						end if
					end if
				end if
			end if
		end if
		read_ptr = read_ptr + 1
	end while
end

procedure write_reset()
	#Hard maximum 15 meters
	write_ptr = 0
	call hardware_spi_transfer(0, meters, "\x00\x00\x00\x00\x00")
end

procedure blank_strip()
	i = 0
	while(i < led_count)
		call hardware_spi_transfer(0,3,"\x80\x80\x80")
		i = i + 1
	end while
	call write_reset()
end


procedure set_strip_info(num_leds)
	led_count = num_leds
	meters = (led_count+31)/32
end

procedure set_color(v)
	if (write_ptr < 256)
		stripA(write_ptr:1) = v
	else
		if (write_ptr < 512)
			stripB((write_ptr-256):1) = v
		else 
			if (write_ptr < 768)
				stripC((write_ptr-512):1) = v
			else 
				if (write_ptr < 1024)
					stripD((write_ptr-768):1) = v
				else 
					if (write_ptr < 1280)
						stripE((write_ptr-1024):1) = v
					else 
						if (write_ptr < 1536)
							stripF((write_ptr-1280):1) = v
						end if
					end if
				end if
			end if
		end if
	end if
	write_ptr = write_ptr + 1
	if (write_ptr >= (led_count*3))
		call write_pixels()
		call write_reset()
	end if
end

#Values should have the high bit set
procedure set_rgb(r, g, b)
	#Little endian, grb -> brg
	call set_color(b | $80)
	call set_color(r | $80)
	call set_color(g | $80)
end

#Listen for boot
event system_boot(major, minor, patch, build,ll_version, protocol,hw)
	connected = 0
	write_ptr = 0
	read_ptr = 0
	call set_strip_info(160)
	
	call sm_set_bondable_mode(1)

	call hardware_io_port_config_direction(1,1) #P1.0 is output
	call hardware_io_port_config_direction(1,3) #P1.1 is output
	call hardware_io_port_write(1,3,3)
	
	call gap_set_adv_parameters(320, 480, 7)

    # put module into discoverable/connectable mode
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
	call blank_strip()
	call hardware_io_port_write(1,3,0)
end

#Listen for bluetooth
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
	if connected = 0 then
        # Set up a connection interval of between 6*1.25ms to 10*1.25ms (7.5-12.5ms)
        # Android (and iOS?) respond to connection interval updates, but cannot set them
        call connection_update(connection, 6, 10, latency, timeout)
    end if
	call hardware_io_port_write(1,2,2)
    connected = 1
end

event connection_disconnected(handle, result)
	connected = 0
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
	call hardware_io_port_write(1,2,0)
end

# Handles OTA Control Point Attribute (commands) and OTA Data Attribute (firmware update) writes
# and performs the necessary actions
procedure handle_ota_control(connection, offset, value_len, value_data())
    # Check if OTA control point attribute is written by the remote device and execute the command
        # Command 0 : Erase flash block 0 (0x0-0x1FFFF)
        # Command 1 : Erase flash block 1 (0x10000-0x3FFFF)
        # Command 2 : Reset DFU data pointer
        # Command 3 : Boot to DFU mode
        # Command 4 : Power up external flash
    # In case of errors application error code 0x80 is returned to the remote device
    # In case the flash comms fails error code 0x90 is returned to the remote device
    
    # Attribute is user attribute, reason is always write_request_user
    if value_len > 1 || offset > 0 then
        # Not a valid command -> report application error code : 0x80
        call attributes_user_write_response(connection, $80)
    else
        command = value_data(0:1)

        if command > 4 then # Unknown command -> report application error code : 0x80
            call attributes_user_write_response(connection, $80)
        else
            if command = 3 then # Command 3 received -> Boot to DFU mode
                call system_reset(1)
            else
                # Other commands are not used, but still accepted in order
                # to be compatible with the external flash OTA
                # implementation
                call attributes_user_write_response(connection, $0)
            end if
        end if
    end if
end

event attributes_value(connection, reason, handle, offset, vlen, value_data)
	call hardware_io_port_write(1,1,1)
	if (handle = device_reset) then
        command=value_data(0:1)
        # Command 1 received, reset device
        if command=1 then  
            call system_reset(0)
        end if
    end if
    
	# Both ota_control endpoints run the same code, however, the wo_response just ignores most of this
    if handle = ota_control || handle = ota_control_wo_response then
        call handle_ota_control(connection, offset, value_len, value_data(0:value_len))
    end if

    # Check if OTA data attribute is written which carries the firmware update
    # and store the data to the internal flash
    if handle = ota_data || handle = ota_data_w_response then
        call flash_write_data(dfu_pointer, value_len, value_data(0:value_len))
        dfu_pointer = dfu_pointer + value_len
    end if

	
	if handle = c_led_data then
		i = (vlen+1)/3
		while( i > 0)
			call set_rgb(value_data(i:1), value_data(i+1:1), value_data(i+2:1))
			i = i - 1
		end while
	else
		if handle = c_led_cmd then
			#CMD API
			#0 : Call write
			#1 + (u16) : set LED count
			if (value_data(0:1) = 0)
				call write_pixels()
				call write_reset()
			else 
				if (value_data(0:1) = 1)
					call set_strip_info(value_data(1:2))
				else
					if (value_data(0:1) = 2)
						call blank_strip()
					end if
				end if
			end if
		end if
	end if
	call hardware_io_port_write(1,1,0)
end
