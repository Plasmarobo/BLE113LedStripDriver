const MAX_METERS = 15 #5m per strip
const MAX_LEDS = 480 #160 leds per m
const MAX_DATA_LEN = 1440

dim meters 
dim led_count
dim i

dim write_ptr
dim read_ptr

#Create a 4 part buffer
dim stripA(256)
dim stripB(256)
dim stripC(256)
dim stripD(256)
dim stripE(256)
dim stripF(256)

dim result

dim in(20) # endpoint data in
dim in_len

dim out(20) # endpoint data out
dim out_len

dim custom_adv_data(9)

dim connected

procedure write_pixels()
	read_ptr = 0
	while(read_ptr < write_ptr)
		if (read_ptr < 256)
			call hardware_spi_transfer(0, 1, stripA(read_ptr:1))
		else
			if (read_ptr < 512)
				call hardware_spi_transfer(0, 1, stripB((read_ptr-256):1))
			else 
				if (read_ptr < 768)
					call hardware_spi_transfer(0, 1, stripC((read_ptr-512):1))
				else 
					if (read_ptr < 1024)
						call hardware_spi_transfer(0, 1, stripD((read_ptr-768):1))
					else 
						if (read_ptr < 1280)
							call hardware_spi_transfer(0, 1, stripE((read_ptr-1024):1))
						else 
							if (read_ptr < 1536)
								call hardware_spi_transfer(0, 1, stripF((read_ptr-1280):1))
							end if
						end if
					end if
				end if
			end if
		end if
		read_ptr = read_ptr + 1
	end while
end

procedure write_reset()
	#Hard maximum 15 meters
	write_ptr = 0
	call hardware_spi_transfer(0, meters, "\x00\x00\x00\x00\x00")
end

procedure blank_strip()
	i = 0
	while(i < led_count)
		call hardware_spi_transfer(0,3,"\x80\x80\x80")
		i = i + 1
	end while
	call write_reset()
end


procedure set_strip_info(num_leds)
	led_count = num_leds
	meters = (led_count+31)/32
end

procedure set_color(v)
	if (write_ptr < 256)
		stripA(write_ptr:1) = v
	else
		if (write_ptr < 512)
			stripB((write_ptr-256):1) = v
		else 
			if (write_ptr < 768)
				stripC((write_ptr-512):1) = v
			else 
				if (write_ptr < 1024)
					stripD((write_ptr-768):1) = v
				else 
					if (write_ptr < 1280)
						stripE((write_ptr-1024):1) = v
					else 
						if (write_ptr < 1536)
							stripF((write_ptr-1280):1) = v
						end if
					end if
				end if
			end if
		end if
	end if
	write_ptr = write_ptr + 1
	if (write_ptr >= (led_count*3))
		call write_pixels()
		call write_reset()
	end if
end

#Values should have the high bit set
procedure set_rgb(r, g, b)
	#Little endian, grb -> brg
	call set_color(b | $80)
	call set_color(r | $80)
	call set_color(g | $80)
end

#Listen for boot
event system_boot(major, minor, patch, build,ll_version, protocol,hw)
	connected = 0
	write_ptr = 0
	read_ptr = 0
	call set_strip_info(160)

	call hardware_io_port_config_direction(1,1) #P1.0 is output
	call hardware_io_port_config_direction(1,3) #P1.1 is output
	call hardware_io_port_write(1,3,3)
	call system_endpoint_tx(system_endpoint_uart1, 37, "\n\r** Boot: LED Strip system boot **\n\r")

	call gap_set_adv_parameters(320, 480, 7)
	
    call system_endpoint_set_watermarks(5, 0, 0) # disable watermarks

    # put module into discoverable/connectable mode
    call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)

	call blank_strip()
	call hardware_io_port_write(1,3,0)
end

#Listen for bluetooth
event connection_status(connection, flags, address, address_type, conn_interval, timeout, latency, bonding)
	if connected = 0 then
        # Set up a connection interval of between 6*1.25ms to 10*1.25ms (7.5-12.5ms)
        # Android (and iOS?) respond to connection interval updates, but cannot set them
        call connection_update(connection, 6, 10, latency, timeout)
    end if
	call system_endpoint_tx(system_endpoint_uart1, 11, "Connected\n\r")
	call hardware_io_port_write(1,2,2)
    connected = 1
end

event connection_disconnected(handle, res)
	connected = 0
	call gap_set_mode(gap_general_discoverable, gap_undirected_connectable)
	call system_endpoint_tx(system_endpoint_uart1, 14, "Disconnected\n\r")
	call hardware_io_port_write(1,2,0)
end

event attributes_status(handle, flags)

    if (handle = xgatt_debug) && (flags = 2) then
    
       call system_endpoint_tx(system_endpoint_uart1, 16, "xgatt data rec\n\r")

       call system_endpoint_set_watermarks(5, 1, 0) # set RX watermark
       
    end if

end

event system_endpoint_watermark_rx(endpoint, size)

    in_len = size
    if in_len > 20 then
       in_len = 20
    end if
    call system_endpoint_set_watermarks(5, 0, $ff) # disable RX watermark
    call system_endpoint_rx(5, in_len)(result, in_len, in(0:in_len))
    call attributes_write(xgatt_debug, 0, in_len, in(0:in_len))
    
end

event attclient_indicated(connection, handle)

    if handle = xgatt_debug then
        call system_endpoint_set_watermarks(5, 1, $ff) # set RX watermark
    end if
    
end

event attributes_value(connection, reason, handle, offset, vlen, value_data)
	call hardware_io_port_write(1,1,1)

	if handle = c_led_data then
		call system_endpoint_tx(system_endpoint_uart1, 19 , "LED Data recieved\n\r")
		i = (vlen+1)/3
		while( i > 0)
			call set_rgb(value_data(i:1), value_data(i+1:1), value_data(i+2:1))
			i = i - 1
		end while
	end if 
	
	if handle = xgatt_debug then
        out(0:vlen) = value_data(0:vlen)
        out_len = vlen
        call system_endpoint_set_watermarks(5, $ff, out_len) # set TX watermark
    end if
	
	if handle = c_led_cmd then
		#CMD API
		#0 : Call write
		#1 + (u16) : set LED count
		call system_endpoint_tx(5, 57, "\r++ Recieved Command: ")
		if (value_data(0:1) = 0)
			call system_endpoint_tx(5, 57, "Write Strip++\n")
			call write_pixels()
			call write_reset()
		else 
			if (value_data(0:1) = 1)
				call set_strip_info(value_data(1:2))
				call system_endpoint_tx(5, 57, "Set Strip info ++\n")
			else
				if (value_data(0:1) = 2)
					call system_endpoint_tx(5, 57, "Blank Strip ++\n")
					call blank_strip()
					
				else
					if (value_data(0:1) = 3)
						call system_endpoint_tx(5, 57, "System Reset ++\n")
						call system_reset(0)
					end if
				end if
			end if
		end if
	end if
	call system_endpoint_tx(system_endpoint_uart1, 10, "==Data==\n\r")
	call system_endpoint_tx(system_endpoint_uart1, vlen, value_data(0:vlen))
	call system_endpoint_tx(system_endpoint_uart1, 9, "\n\r==End==\n\r")
	call hardware_io_port_write(1,1,0)
end

event system_endpoint_watermark_tx(endpoint, size)

    if endpoint = 5 then
        call system_endpoint_set_watermarks(5, $ff, 0) # disable TX watermark
        call system_endpoint_tx(5, out_len, out(0:out_len))
        call attributes_user_write_response(0, 0)
    end if
    
end

event system_endpoint_watermark_rx(endpoint, size)
  if endpoint = system_endpoint_uart1 then
    in_len = size
    call system_endpoint_set_watermarks(system_endpoint_uart1, 0, $ff) # disable RX watermark
    call system_endpoint_rx(system_endpoint_uart1, in_len)(result, in_len, in(0:in_len)) # read data from UART
    call system_endpoint_set_watermarks(system_endpoint_uart1, 10, $ff) # enable RX watermark
    call attributes_write(xgatt_debug, 0, in_len, in(0:in_len)) # Write data to GATT
  end if
end

event connection_disconnected(conn, reas)
    
    call system_endpoint_tx(5, 22, "\n\n\r-- Disconnected --\n")
    call system_endpoint_tx(5, 17, "\r-- Reason code: ")
    call system_endpoint_tx(5, 2, reas)
    call system_endpoint_tx(5, 4, " --\n")

    call system_endpoint_set_watermarks(5, 0, 0) # disable watermarks
    
    call gap_set_mode(2, 2)

end
